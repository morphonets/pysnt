{
  "class_name": "PersistenceAnalyzer",
  "package": "sc.fiji.snt.analysis",
  "extracted_at": "2025-11-19T11:06:20.569092",
  "extractor_version": "1.0.0",
  "enhancement_timestamp": "2025-11-22T08:11:21.356699",
  "enhancement_version": "1.0.0",
  "methods": [
    {
      "name": "getBarcode",
      "overloads": [
        {
          "signature": "getBarcode(String) -> List",
          "params": [
            {
              "name": "arg0",
              "type": "str",
              "java_type": "String",
              "description": "- A descriptor for the filter function as per getDescriptors() (case-insensitive). Supported values: \"geodesic\", \"radial\", \"centrifugal\", \"path order\", \"x\", \"y\", \"z\".",
              "javadoc_name": "descriptor"
            }
          ],
          "return_type": "List[Any]",
          "java_return_type": "List",
          "return_description": "the barcode as a list of persistence values (death - birth). Each value represents the \"lifespan\" or significance of a topological feature (branch).",
          "throws": {
            "UnknownMetricException": "- If",
            "descriptor": "is not recognized as a valid filter function"
          }
        }
      ],
      "documentation": "Java method: getBarcode",
      "javadoc_description": "Gets the persistence barcode for the specified filter function.\n\nThe barcode is a simplified representation of the persistence diagram that contains only the persistence values (death - birth) for each topological feature, akin to a one-dimensional summary of branch significance.\n\nInterpretation:\n\nHigh values: Morphologically significant branches Low values: Minor branches or potential noise Distribution: The spread of values indicates branching complexity\n\nSpecial Properties:\n\nAll values are non-negative (|death - birth|) For geodesic descriptor: sum of all values equals total cable length Number of values equals number of tips in the tree\n\nExample Usage: \n```\nList<Double> barcode = analyzer.getBarcode(\"geodesic\");\n\n// Find most significant branches\nbarcode.sort(Collections.reverseOrder());\nSystem.out.println(\"Top 5 most persistent branches:\");\nfor (int i = 0; i < Math.min(5, barcode.size()); i++) {\n    System.out.println(\"Branch \" + (i+1) + \": \" + barcode.get(i));\n}\n```\n",
      "category": "Getters",
      "deprecated": false,
      "since_version": null,
      "see_also": [
        "for full birth-death pairs",
        "for associated tree nodes"
      ],
      "examples": [
        "List<Double> barcode = analyzer.getBarcode(\"geodesic\");\n\n// Find most significant branches\nbarcode.sort(Collections.reverseOrder());\nSystem.out.println(\"Top 5 most persistent branches:\");\nfor (int i = 0; i < Math.min(5, barcode.size()); i++) {\n    System.out.println(\"Branch \" + (i+1) + \": \" + barcode.get(i));\n}",
        "List<Double> barcode = analyzer.getBarcode(\"geodesic\");\n\n// Find most significant branches\nbarcode.sort(Collections.reverseOrder());\nSystem.out.println(\"Top 5 most persistent branches:\");\nfor (int i = 0; i < Math.min(5, barcode.size()); i++) {\n    System.out.println(\"Branch \" + (i+1) + \": \" + barcode.get(i));\n}"
      ]
    },
    {
      "name": "static getDescriptors",
      "overloads": [
        {
          "signature": "static getDescriptors() -> List",
          "params": [],
          "return_type": "List[Any]",
          "java_return_type": "List",
          "return_description": "the list of available descriptors: [\"geodesic\", \"radial\", \"centrifugal\", \"path order\", \"x\", \"y\", \"z\"]",
          "throws": {}
        }
      ],
      "documentation": "Java method: static getDescriptors",
      "javadoc_description": "Gets a list of supported descriptor functions for persistence analysis.\n\nReturns the string identifiers for all available filter functions that can be used with getDiagram(String), getBarcode(String), and other analysis methods. These descriptors are case-insensitive when used in method calls.",
      "category": "Static Methods",
      "deprecated": false,
      "since_version": null,
      "see_also": [
        "getDiagram(String)",
        "getBarcode(String)",
        "getLandscape(String, int, int)"
      ],
      "examples": []
    },
    {
      "name": "getDiagram",
      "overloads": [
        {
          "signature": "getDiagram(String) -> List",
          "params": [
            {
              "name": "arg0",
              "type": "str",
              "java_type": "String",
              "description": "- A descriptor for the filter function as per getDescriptors() (case-insensitive). Supported values: \"geodesic\", \"radial\", \"centrifugal\", \"path order\", \"x\", \"y\", \"z\". Alternative names like \"reverse strahler\" for \"centrifugal\" are also accepted.",
              "javadoc_name": "descriptor"
            }
          ],
          "return_type": "List[Any]",
          "java_return_type": "List",
          "return_description": "the persistence diagram as a list of [birth, death] pairs. Each inner list contains exactly two Double values representing the birth and death of a topological feature.",
          "throws": {
            "UnknownMetricException": "- If",
            "descriptor": "is not recognized as a valid filter function"
          }
        }
      ],
      "documentation": "Java method: getDiagram",
      "javadoc_description": "Gets the persistence diagram for the specified filter function.\n\nThe persistence diagram is the core output of the analysis, consisting of birth-death pairs that represent the \"lifespan\" of topological features (branches) during the filtration process. Each point in the diagram corresponds to a branch in the neuronal tree.\n\nStructure: Returns a list where each inner list contains exactly two values:\n\nBirth [0]: The filter value where the branch appears (branch point) Death [1]: The filter value where the branch disappears (tip)\n\nProperties:\n\nNumber of points = Number of tips in the tree All values are non-negative For geodesic descriptor: sum of all (death-birth) = total cable length High persistence (death-birth) indicates morphologically significant branches\n\nExample usage: \n```\nList<List<Double>> diagram = analyzer.getDiagram(\"geodesic\");\nfor (List<Double> point : diagram) {\n    double birth = point.get(0);\n    double death = point.get(1);\n    double persistence = death - birth;\n    System.out.println(\"Branch: persistence = \" + persistence);\n}\n```\n",
      "category": "Getters",
      "deprecated": false,
      "since_version": null,
      "see_also": [
        "for persistence values only",
        "for associated tree nodes",
        "for available descriptors"
      ],
      "examples": [
        "List<List<Double>> diagram = analyzer.getDiagram(\"geodesic\");\nfor (List<Double> point : diagram) {\n    double birth = point.get(0);\n    double death = point.get(1);\n    double persistence = death - birth;\n    System.out.println(\"Branch: persistence = \" + persistence);\n}",
        "List<List<Double>> diagram = analyzer.getDiagram(\"geodesic\");\nfor (List<Double> point : diagram) {\n    double birth = point.get(0);\n    double death = point.get(1);\n    double persistence = death - birth;\n    System.out.println(\"Branch: persistence = \" + persistence);\n}"
      ]
    },
    {
      "name": "getDiagramNodes",
      "overloads": [
        {
          "signature": "getDiagramNodes(String) -> List",
          "params": [
            {
              "name": "arg0",
              "type": "str",
              "java_type": "String",
              "description": "- A descriptor for the filter function as per getDescriptors() (case-insensitive). Supported values: \"geodesic\", \"radial\", \"centrifugal\", \"path order\", \"x\", \"y\", \"z\".",
              "javadoc_name": "descriptor"
            }
          ],
          "return_type": "List[Any]",
          "java_return_type": "List",
          "return_description": "the persistence diagram nodes as a list of [birth_node, death_node] pairs. Each inner list contains exactly two SWCPoint objects representing the spatial locations of the topological feature.",
          "throws": {
            "UnknownMetricException": "- If",
            "descriptor": "is not recognized as a valid filter function"
          }
        }
      ],
      "documentation": "Java method: getDiagramNodes",
      "javadoc_description": "Gets the tree nodes associated with each point in the persistence diagram.\n\nThis method returns the actual SWCPoint nodes from the neuronal tree that correspond to each birth-death pair in the persistence diagram. This allows you to map topological features back to specific locations in the original morphology.\n\nStructure: Returns a list where each inner list contains exactly two nodes:\n\nBirth Node [0]: The branch point where the topological feature appears Death Node [1]: The tip node where the topological feature disappears\n\nCorrespondence: The order of node pairs matches the order of birth-death pairs returned by getDiagram(String), allowing direct correlation between topological features and their spatial locations.\n\nExample Usage: \n```\nList<List<Double>> diagram = analyzer.getDiagram(\"geodesic\");\nList<List<SWCPoint>> nodes = analyzer.getDiagramNodes(\"geodesic\");\n\nfor (int i = 0; i < diagram.size(); i++) {\n    List<Double> birthDeath = diagram.get(i);\n    List<SWCPoint> nodesPair = nodes.get(i);\n    \n    double persistence = birthDeath.get(1) - birthDeath.get(0);\n    SWCPoint branchPoint = nodesPair.get(0);\n    SWCPoint tipPoint = nodesPair.get(1);\n    \n    System.out.printf(\"Branch with persistence %.2f: from (%.1f,%.1f,%.1f) to (%.1f,%.1f,%.1f)%n\",\n                      persistence, \n                      branchPoint.getX(), branchPoint.getY(), branchPoint.getZ(),\n                      tipPoint.getX(), tipPoint.getY(), tipPoint.getZ());\n}\n```\n",
      "category": "Getters",
      "deprecated": false,
      "since_version": null,
      "see_also": [
        "for corresponding birth-death values",
        "for persistence values only",
        "for node properties and methods"
      ],
      "examples": [
        "List<List<Double>> diagram = analyzer.getDiagram(\"geodesic\");\nList<List<SWCPoint>> nodes = analyzer.getDiagramNodes(\"geodesic\");\n\nfor (int i = 0; i < diagram.size(); i++) {\n    List<Double> birthDeath = diagram.get(i);\n    List<SWCPoint> nodesPair = nodes.get(i);\n    \n    double persistence = birthDeath.get(1) - birthDeath.get(0);\n    SWCPoint branchPoint = nodesPair.get(0);\n    SWCPoint tipPoint = nodesPair.get(1);\n    \n    System.out.printf(\"Branch with persistence %.2f: from (%.1f,%.1f,%.1f) to (%.1f,%.1f,%.1f)%n\",\n                      persistence, \n                      branchPoint.getX(), branchPoint.getY(), branchPoint.getZ(),\n                      tipPoint.getX(), tipPoint.getY(), tipPoint.getZ());\n}",
        "List<List<Double>> diagram = analyzer.getDiagram(\"geodesic\");\nList<List<SWCPoint>> nodes = analyzer.getDiagramNodes(\"geodesic\");\n\nfor (int i = 0; i < diagram.size(); i++) {\n    List<Double> birthDeath = diagram.get(i);\n    List<SWCPoint> nodesPair = nodes.get(i);\n    \n    double persistence = birthDeath.get(1) - birthDeath.get(0);\n    SWCPoint branchPoint = nodesPair.get(0);\n    SWCPoint tipPoint = nodesPair.get(1);\n    \n    System.out.printf(\"Branch with persistence %.2f: from (%.1f,%.1f,%.1f) to (%.1f,%.1f,%.1f)%n\",\n                      persistence, \n                      branchPoint.getX(), branchPoint.getY(), branchPoint.getZ(),\n                      tipPoint.getX(), tipPoint.getY(), tipPoint.getZ());\n}"
      ]
    },
    {
      "name": "getLandscape",
      "overloads": [
        {
          "signature": "getLandscape(String, int, int) -> [D",
          "params": [
            {
              "name": "arg0",
              "type": "str",
              "java_type": "String",
              "description": "- A descriptor for the filter function as per getDescriptors() (case-insensitive). Supported values: \"geodesic\", \"radial\", \"centrifugal\", \"path order\", \"x\", \"y\", \"z\".",
              "javadoc_name": "descriptor"
            },
            {
              "name": "arg1",
              "type": "int",
              "java_type": "int",
              "description": "",
              "javadoc_name": "getDescriptors()"
            },
            {
              "name": "arg2",
              "type": "int",
              "java_type": "int",
              "description": "",
              "javadoc_name": "param_2"
            }
          ],
          "return_type": "Any",
          "java_return_type": "[D",
          "return_description": "the persistence landscape as a 1D array of length `numLandscapes × resolution`. All values are non-negative and scaled by √2 for proper L² normalization.",
          "throws": {
            "UnknownMetricException": "- If",
            "descriptor": "is not recognized as a valid filter function"
          }
        }
      ],
      "documentation": "Java method: getLandscape",
      "javadoc_description": "Gets the persistence landscape as a vectorized representation.\n\nPersistence landscapes transform persistence diagrams into a vector space representation that The landscape is a collection of piecewise-linear functions that capture the \"shape\" of the persistence diagram in a stable, vectorized format.\n\nMathematical Background: Each point (birth, death) in the persistence diagram contributes a \"tent\" function to the landscape. The k-th landscape function at any point is the k-th largest value among all tent functions at that point. This creates a stable, multi-resolution representation of the topological features.\n\nOutput Structure: Returns a 1D array of length `numLandscapes × resolution` where the first resolution values represent the first landscape function, the next resolution values represent the second landscape function, and so on.",
      "category": "Getters",
      "deprecated": false,
      "since_version": null,
      "see_also": [
        "for the underlying persistence diagram",
        "Bubenik (2015) JMLR"
      ],
      "examples": []
    },
    {
      "name": "static main",
      "overloads": [
        {
          "signature": "static main(String;) -> void",
          "params": [
            {
              "name": "arg0",
              "type": "Any",
              "java_type": "String;",
              "description": "",
              "javadoc_name": "param_0"
            }
          ],
          "return_type": "None",
          "java_return_type": "void",
          "return_description": "",
          "throws": {}
        }
      ],
      "documentation": "Java method: static main",
      "javadoc_description": "",
      "category": "Static Methods",
      "deprecated": false,
      "since_version": null,
      "see_also": [],
      "examples": []
    }
  ],
  "fields": [],
  "constructors": [
    {
      "name": "__init__",
      "overloads": [
        {
          "signature": "PersistenceAnalyzer(Tree)",
          "params": [
            {
              "name": "arg0",
              "type": "Tree",
              "java_type": "Tree"
            }
          ],
          "return_type": "None",
          "java_return_type": "void"
        }
      ],
      "documentation": "Java constructors for PersistenceAnalyzer"
    }
  ],
  "javadoc_description": "Performs persistent homology analysis on neuronal Trees.\n\nThis class implements the algorithm described in Kanari, L. et al. \"A Topological Representation of Branching Neuronal Morphologies\" (Neuroinformatics 16, 3–13, 2018) to extract topological features from neuronal morphologies.\n\nCore Concepts\n\nFilter Functions: Mathematical functions that assign scalar values to each node in the tree based on various morphological properties (distance from root, branch order, spatial coordinates, etc.).\n\nPersistence Diagram: A collection of 2D points (birth, death) representing when topological features (branches) appear and disappear during a filtration process. Each point corresponds to a branch in the neuronal tree.\n\nPersistence: The \"lifespan\" of a topological feature, calculated as death - birth. High persistence indicates morphologically significant branches, while low persistence may represent noise or minor branches.\n\nSupported Filter Functions\n\nGeodesic: Path distance from node to root along the tree structure Radial: Euclidean (straight-line) distance from node to root Centrifugal: Reverse Strahler number (branch order from tips) Path Order: SNT path order hierarchy X, Y, Z: Spatial coordinates for directional analysis\n\nUsage Example \n```\n// Create analyzer for a neuronal tree\nPersistenceAnalyzer analyzer = new PersistenceAnalyzer(tree);\n\n// Get persistence diagram using geodesic distance\nList<List<Double>> diagram = analyzer.getDiagram(\"geodesic\");\n\n// Each inner list contains [birth, death] values\nfor (List<Double> pair : diagram) {\n    double birth = pair.get(0);\n    double death = pair.get(1);\n    double persistence = death - birth;\n    System.out.println(\"Branch: birth=\" + birth + \", death=\" + death + \", persistence=\" + persistence);\n}\n\n// Get persistence landscape\ndouble[] landscape = analyzer.getLandscape(\"geodesic\", 5, 100);\n```\n",
  "inheritance": {
    "extends": [
      "Object"
    ],
    "implements": []
  },
  "nested_classes": [],
  "deprecated": false,
  "since_version": null,
  "see_also": [
    "for persistence values only",
    "for the underlying persistence diagram",
    "getDiagram(String)",
    "getBarcode(String)",
    "for full birth-death pairs",
    "for corresponding birth-death values",
    "for node properties and methods",
    "for tree structure requirements",
    "getLandscape(String, int, int)",
    "Bubenik (2015) JMLR",
    "to begin analysis",
    "Kanari et al. (2018) Neuroinformatics",
    "Tree",
    "for associated tree nodes",
    "for available descriptors",
    "Object"
  ],
  "enhancement_metadata": {
    "matching_statistics": {
      "total_javadoc_methods": 6,
      "total_json_methods": 6,
      "total_matches": 6,
      "exact_matches": 6,
      "signature_matches": 0,
      "fuzzy_matches": 0,
      "name_only_matches": 0,
      "unmatched_javadoc": 0,
      "unmatched_json": 0,
      "match_percentage": 100.0
    },
    "unmatched_javadoc_methods": 0,
    "unmatched_json_methods": 0,
    "enhancement_quality_score": 1.0
  }
}